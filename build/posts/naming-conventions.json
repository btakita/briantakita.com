{"html":"<p>Note: The naming convention described in this article\n  <a target=\"_blank\" href=\"/posts/multi-underscore-tag-naming-convention-analysis\">has been named</a>:</p>\n<p>Long form: Multi Underscore Tag Naming Convention</p>\n<p>Medium form: Tag Naming Convention</p>\n<p>Short Form: Tag Naming</p>\n<hr>\n<p>An Abstraction name encodes the meaning &amp; context of the abstraction.\nThe name consists of tags that are joined together to create a name.</p>\n<a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\">\n  Naming Convention (programming) (Wikipedia)\n</a>\n\n<h2 id=\"discoverability-unique-vs-ambiguous-names\">Discoverability: Unique vs Ambiguous Names</h2>\n<p>A name &amp; tags in the name also acts identifiers to locate\n  the usages of the abstraction in the codebase.\nThis attribute is also known as discoverability.</p>\n<p><a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Discoverability\">Discoverability (Wikipedia)</a></p>\n<p>Unique &amp; Accurate names for abstractions help discoverability.\nAmbiguous names hurt discoverability.</p>\n<p>Advantages for discoverable abstractions include:</p>\n<ul>\n<li>easy searching for an abstraction used across the codebase</li>\n<li>easier refactoring (e.g. a rename refactoring is a search/replace)</li>\n<li>provides a more comprehensive &amp; accurate model of the system in one&#39;s head</li>\n</ul>\n<hr class=\"more\"/>\n\n<h3 id=\"ambiguous-name-example--id\">Ambiguous name Example â€” <code>id</code></h3>\n<p><code>id</code> fields with context are a good candidate to combine into a single tag.</p>\n<p>Note that it&#39;s advantageous to name a field <code>user.user_id</code>\n  instead of <code>user.id</code> because the abstraction <code>user_id</code> can be located\n    though a search wherever it is used.\nThe convention held by <code>ActiveRecord</code> in <code>Ruby on Rails</code> \n  makes it difficult to find usages of the <code>user_id</code> abstraction,\n  particularly when it is used in objects.\nIn the <code>user</code> object, <code>user_id</code> is named <code>id</code>,\n  which is ambiguous with all the other <code>*_id</code> fields used in all of the other relations.\nFor reason of unambiguous distinction, it is advantageous to always use the same form for <code>user_id</code>.</p>\n<h2 id=\"top-down--bottom-up-design\">Top-down &amp; Bottom-up Design</h2>\n<a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design\">\n  Top-down and bottom-up design (Wikipedia)\n</a>\n\n<p>One can communicate &amp; gain design feedback on a system design by thinking\n  in terms of top-down &amp; bottom-up design.\nThe typical naming convention in software systems is to have a top-down convention\n  where the leftmost part of the name is the most global, becoming more local when moving rightward.</p>\n<p>One can also think bottom-up by moving from the right to the left in a name.\nThinking both top-down &amp; bottom-up is often a useful exercise \n  in understanding &amp; discerning the naming of an abstraction.</p>\n<h2 id=\"underscore_casing\">Underscore_casing</h2>\n<p>Underscore casing separates each word in a tag with an underscore <code>_</code>.\nUnderscores are also used to separate tags when multiple tags are combined to form a name.</p>\n<h2 id=\"camelcasing\">CamelCasing</h2>\n<p>Camel casing is often used for variable &amp; class names.\nWhile that works to identify a name tag,\n  there are ambiguities when composing multiple tags together to form a name.</p>\n<p>For example, the casing may be changed.</p>\n<p><code>const btoaEncodeURIComponentUserJson = btoa(encodeURIComponent(JSON.stringify(user)))</code></p>\n<p>Composing a camelCased tag with underscores removes this ambiguity:</p>\n<p><code>const btoa_encodeURIComponent_user_json = btoa(encodeURIComponent(JSON.stringify(user)))</code></p>\n<h2 id=\"double__underscore__casing-__\">Double__Underscore__Casing (<code>__</code>)</h2>\n<p>Double Underscores are used to aggregate a new chain of tags.</p>\n<h3 id=\"bottom-up-naming\">Bottom-up naming</h3>\n<p>If the typical use case is top-down naming (<code>global_context_mid_context_local</code>),\n  to achieve bottom-up naming, one could use <code>__</code> to join each tag (<code>local__mid_context__global_context</code>).</p>\n<h3 id=\"event-handler-names---__click-as-shorthand-for-onclick\">Event Handler Names - <code>__click</code> as shorthand for <code>onclick</code></h3>\n<p>A name that begins with <code>__</code> can be though of as an unassigned local tag followed by contextual tags.\nThis technique can be used to name event handlers.</p>\n<h3 id=\"context-object-names---__user-as-shorthand-for-ctx__user\">Context Object Names - <code>__user</code> as shorthand for <code>ctx__user</code></h3>\n<p>At times, it may be useful to have a ctx object representing a group of abstractions related to a certain tag.</p>\n<pre><code class=\"language-js\">const __user = {\n  user_name: &#39;Joe&#39;,\n  user_id: 44,\n  user: {user_id: 44, user_name: &#39;Joe&#39;},\n  user_orders_transactions: [{\n    order_transaction_id: 99,\n    order_id: 54\n  }]}</code></pre>\n<h3 id=\"alternate-names---user__\">Alternate names - <code>user__</code></h3>\n<p>If a name is already used within a scope, it may be useful to define an alternate name.\nThis is useful when a function takes an abstraction, clones it, &amp; returns a new version of the abstraction.</p>\n<pre><code class=\"language-js\">async function refresh_user(user) {\n  const {user_id} = user\n  const response = await fetch_user(user_id)\n  const user__ = await response.json()\n  return user__\n}</code></pre>\n<h2 id=\"factory-functions-_sales_report\">Factory Functions <code>_sales_report</code></h2>\n<p>Factory functions are prefixed with a single <code>_</code>,\n  with the name of the created abstraction following.</p>\n<pre><code class=\"language-js\">const sales_report = _sales_report()</code></pre>\n<p>One can visualize the <code>sales_report</code> flowing from the factory <code>_</code>.</p>\n<p>This technique may be useful in breaking down a function into component parts using scoping.\nIn the following example, these queries are run in parallel using <code>async/await</code> &amp; <code>Promise.all</code>.</p>\n<p>Note that in this example,\n  bottom-up naming is used to highlight that <code>results</code> is the type of the abstraction,\n  with the rest of the name being context named top-down.</p>\n<pre><code class=\"language-js\">async function _sales_report() {\n  const [\n    results__sales_aggregate_query,\n    results__sales_regions_query,\n    results__sales_forecast_query\n  ] = await Promise.all([\n    _results__sales_aggregate_query(),\n    _results__sales_regions_query(),\n    _results__sales_forecast_query()\n  ])\n  return {\n    results__sales_aggregate_query,\n    results__sales_regions_query,\n    results__sales_forecast_query\n  }\n  async function _results__sales_aggregate_query() {\n    // ...\n  }\n  async function _results__sales_regions_query() {\n    // ...\n  }\n  async function _results__sales_forecast_query() {\n    // ...\n  }\n}</code></pre>\n","metadata":{"title":"Naming Conventions","author":"Brian Takita","date":"2/27/18 16:30","description":"Naming Conventions to encode the meaning & context of abstractions","intro":"<p>Note: The naming convention described in this article\n  <a target=\"_blank\" href=\"/posts/multi-underscore-tag-naming-convention-analysis\">has been named</a>:</p>\n<p>Long form: Multi Underscore Tag Naming Convention</p>\n<p>Medium form: Tag Naming Convention</p>\n<p>Short Form: Tag Naming</p>\n<hr>\n<p>An Abstraction name encodes the meaning &amp; context of the abstraction.\nThe name consists of tags that are joined together to create a name.</p>\n<a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\">\n  Naming Convention (programming) (Wikipedia)\n</a>\n\n<h2 id=\"discoverability-unique-vs-ambiguous-names\">Discoverability: Unique vs Ambiguous Names</h2>\n<p>A name &amp; tags in the name also acts identifiers to locate\n  the usages of the abstraction in the codebase.\nThis attribute is also known as discoverability.</p>\n<p><a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Discoverability\">Discoverability (Wikipedia)</a></p>\n<p>Unique &amp; Accurate names for abstractions help discoverability.\nAmbiguous names hurt discoverability.</p>\n<p>Advantages for discoverable abstractions include:</p>\n<ul>\n<li>easy searching for an abstraction used across the codebase</li>\n<li>easier refactoring (e.g. a rename refactoring is a search/replace)</li>\n<li>provides a more comprehensive &amp; accurate model of the system in one&#39;s head</li>\n</ul>\n"},"slug":"naming-conventions","date":"2018-02-27T21:30:00.000Z","txt__date":"2/27/18 16:30","path":"/posts/naming-conventions","url":"https://briantakita.com/posts/naming-conventions"}