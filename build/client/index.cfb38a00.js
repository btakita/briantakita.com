import { a as SvelteComponentDev, b as init, c as safe_not_equal, s as element, w as space, v as text, f as claim_element, g as children, h as detach, x as claim_text, j as add_location, k as insert, z as append, q as mount_component, K as set_data, H as detach_before, F as check_outros, O as destroy_each, E as on_outro, D as group_outros } from './chunk.1987d881.js';
import { f as __class__layout, d as __prepend__footer } from './chunk.7f5cd15f.js';
import './chunk.cd7ed10c.js';
import { a as Date__Local } from './chunk.76d13346.js';

/* src/routes/posts/_PostIntro.html generated by Svelte v3.4.1 */

const file = "src/routes/posts/_PostIntro.html";

function create_fragment(ctx) {
	var section, header, p0, span, t0, h2, a0, t1_value = ctx.post.metadata.title, t1, a0_href_value, t2, div, raw_value = ctx.post.metadata.intro, raw_after, t3, p1, a1, t4, a1_href_value, current;

	var date__local = new Date__Local({
		props: { date: ctx.post.txt__date },
		$$inline: true
	});

	return {
		c: function create() {
			section = element("section");
			header = element("header");
			p0 = element("p");
			span = element("span");
			date__local.$$.fragment.c();
			t0 = space();
			h2 = element("h2");
			a0 = element("a");
			t1 = text(t1_value);
			t2 = space();
			div = element("div");
			raw_after = element('noscript');
			t3 = space();
			p1 = element("p");
			a1 = element("a");
			t4 = text("Full post…");
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true }, false);
			var section_nodes = children(section);

			header = claim_element(section_nodes, "HEADER", {}, false);
			var header_nodes = children(header);

			p0 = claim_element(header_nodes, "P", { class: true }, false);
			var p0_nodes = children(p0);

			span = claim_element(p0_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			date__local.$$.fragment.l(span_nodes);
			span_nodes.forEach(detach);
			p0_nodes.forEach(detach);
			t0 = claim_text(header_nodes, "\n    ");

			h2 = claim_element(header_nodes, "H2", {}, false);
			var h2_nodes = children(h2);

			a0 = claim_element(h2_nodes, "A", { href: true }, false);
			var a0_nodes = children(a0);

			t1 = claim_text(a0_nodes, t1_value);
			a0_nodes.forEach(detach);
			h2_nodes.forEach(detach);
			header_nodes.forEach(detach);
			t2 = claim_text(section_nodes, "\n  ");

			div = claim_element(section_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			raw_after = element('noscript');
			t3 = claim_text(div_nodes, "\n    ");

			p1 = claim_element(div_nodes, "P", { class: true }, false);
			var p1_nodes = children(p1);

			a1 = claim_element(p1_nodes, "A", { href: true }, false);
			var a1_nodes = children(a1);

			t4 = claim_text(a1_nodes, "Full post…");
			a1_nodes.forEach(detach);
			p1_nodes.forEach(detach);
			div_nodes.forEach(detach);
			section_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(span, file, 7, 20, 186);
			p0.className = "date";
			add_location(p0, file, 7, 4, 170);
			a0.href = a0_href_value = ctx.post.path;
			add_location(a0, file, 8, 8, 263);
			add_location(h2, file, 8, 4, 259);
			add_location(header, file, 6, 2, 157);
			a1.href = a1_href_value = "/posts/" + ctx.post.slug;
			add_location(a1, file, 12, 20, 404);
			p1.className = "more";
			add_location(p1, file, 12, 4, 388);
			div.className = "content";
			add_location(div, file, 10, 2, 330);
			section.className = "post intro PostIntro";
			add_location(section, file, 5, 0, 116);
		},

		m: function mount(target, anchor) {
			insert(target, section, anchor);
			append(section, header);
			append(header, p0);
			append(p0, span);
			mount_component(date__local, span, null);
			append(header, t0);
			append(header, h2);
			append(h2, a0);
			append(a0, t1);
			append(section, t2);
			append(section, div);
			append(div, raw_after);
			raw_after.insertAdjacentHTML("beforebegin", raw_value);
			append(div, t3);
			append(div, p1);
			append(p1, a1);
			append(a1, t4);
			current = true;
		},

		p: function update(changed, ctx) {
			var date__local_changes = {};
			if (changed.post) date__local_changes.date = ctx.post.txt__date;
			date__local.$set(date__local_changes);

			if ((!current || changed.post) && t1_value !== (t1_value = ctx.post.metadata.title)) {
				set_data(t1, t1_value);
			}

			if ((!current || changed.post) && a0_href_value !== (a0_href_value = ctx.post.path)) {
				a0.href = a0_href_value;
			}

			if ((!current || changed.post) && raw_value !== (raw_value = ctx.post.metadata.intro)) {
				detach_before(raw_after);
				raw_after.insertAdjacentHTML("beforebegin", raw_value);
			}

			if ((!current || changed.post) && a1_href_value !== (a1_href_value = "/posts/" + ctx.post.slug)) {
				a1.href = a1_href_value;
			}
		},

		i: function intro(local) {
			if (current) return;
			date__local.$$.fragment.i(local);

			current = true;
		},

		o: function outro(local) {
			date__local.$$.fragment.o(local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(section);
			}

			date__local.$destroy();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { post } = $$props;

	$$self.$set = $$props => {
		if ('post' in $$props) $$invalidate('post', post = $$props.post);
	};

	return { post };
}

class PostIntro extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["post"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.post === undefined && !('post' in props)) {
			console.warn("<PostIntro> was created without expected prop 'post'");
		}
	}

	get post() {
		throw new Error("<PostIntro>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set post(value) {
		throw new Error("<PostIntro>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/blog/index.html generated by Svelte v3.4.1 */

const file$1 = "src/routes/blog/index.html";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.post = list[i];
	return child_ctx;
}

// (18:2) {#each posts as post}
function create_each_block(ctx) {
	var current;

	var postintro = new PostIntro({
		props: { post: ctx.post },
		$$inline: true
	});

	return {
		c: function create() {
			postintro.$$.fragment.c();
		},

		l: function claim(nodes) {
			postintro.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(postintro, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var postintro_changes = {};
			if (changed.posts) postintro_changes.post = ctx.post;
			postintro.$set(postintro_changes);
		},

		i: function intro(local) {
			if (current) return;
			postintro.$$.fragment.i(local);

			current = true;
		},

		o: function outro(local) {
			postintro.$$.fragment.o(local);
			current = false;
		},

		d: function destroy(detaching) {
			postintro.$destroy(detaching);
		}
	};
}

function create_fragment$1(ctx) {
	var div, current;

	var each_value = ctx.posts;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function outro_block(i, detaching, local) {
		if (each_blocks[i]) {
			if (detaching) {
				on_outro(() => {
					each_blocks[i].d(detaching);
					each_blocks[i] = null;
				});
			}

			each_blocks[i].o(local);
		}
	}

	return {
		c: function create() {
			div = element("div");

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			div.className = "posts";
			add_location(div, file$1, 16, 0, 512);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.posts) {
				each_value = ctx.posts;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						each_blocks[i].i(1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].i(1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();
				for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

async function preload({ params, query }) {
	  const response = await this.fetch('posts.json');
  const posts = await response.json();
  return { posts }
	}

function instance$1($$self, $$props, $$invalidate) {
	
  let { posts } = $$props;
  __class__layout.set('articles');
  __prepend__footer.set(`<div class="nav"><a href="/blog/archive"> « Blog Archives</a></div>`);

	$$self.$set = $$props => {
		if ('posts' in $$props) $$invalidate('posts', posts = $$props.posts);
	};

	return { posts };
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["posts"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.posts === undefined && !('posts' in props)) {
			console.warn("<Index> was created without expected prop 'posts'");
		}
	}

	get posts() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set posts(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Index;
export { preload };
//# sourceMappingURL=index.cfb38a00.js.map
