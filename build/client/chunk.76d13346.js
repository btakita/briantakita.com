import { a as SvelteComponentDev, b as init, c as safe_not_equal, v as text, x as claim_text, k as insert, K as set_data, G as noop, h as detach, q as mount_component } from './chunk.1987d881.js';
import { a as format__date__prose, b as _date__append__local_tz } from './chunk.cd7ed10c.js';

/* home/brian/work/briantakita.com/packages/ctx-core/packages/date/Date.html generated by Svelte v3.4.1 */

function create_fragment(ctx) {
	var t_value = format__date__prose(ctx.date), t;

	return {
		c: function create() {
			t = text(t_value);
		},

		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},

		m: function mount(target, anchor) {
			insert(target, t, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.date) && t_value !== (t_value = format__date__prose(ctx.date))) {
				set_data(t, t_value);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { date } = $$props;

	$$self.$set = $$props => {
		if ('date' in $$props) $$invalidate('date', date = $$props.date);
	};

	return { date };
}

class Date extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["date"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.date === undefined && !('date' in props)) {
			console.warn("<Date> was created without expected prop 'date'");
		}
	}

	get date() {
		throw new Error("<Date>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set date(value) {
		throw new Error("<Date>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/brian/work/briantakita.com/packages/ctx-core/packages/date/Date__Local.html generated by Svelte v3.4.1 */

function create_fragment$1(ctx) {
	var current;

	var date_1 = new Date({
		props: { date: _date__append__local_tz(ctx.date) },
		$$inline: true
	});

	return {
		c: function create() {
			date_1.$$.fragment.c();
		},

		l: function claim(nodes) {
			date_1.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(date_1, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var date_1_changes = {};
			if (changed._date__append__local_tz || changed.date) date_1_changes.date = _date__append__local_tz(ctx.date);
			date_1.$set(date_1_changes);
		},

		i: function intro(local) {
			if (current) return;
			date_1.$$.fragment.i(local);

			current = true;
		},

		o: function outro(local) {
			date_1.$$.fragment.o(local);
			current = false;
		},

		d: function destroy(detaching) {
			date_1.$destroy(detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	
	let { date } = $$props;

	$$self.$set = $$props => {
		if ('date' in $$props) $$invalidate('date', date = $$props.date);
	};

	return { date };
}

class Date__Local extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["date"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.date === undefined && !('date' in props)) {
			console.warn("<Date__Local> was created without expected prop 'date'");
		}
	}

	get date() {
		throw new Error("<Date__Local>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set date(value) {
		throw new Error("<Date__Local>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Date__Local as a };
//# sourceMappingURL=chunk.76d13346.js.map
